# Recursive Verification

Recursive zkSNARKs open up a new paradigm of computation on blockchains. A zkSNARK is a powerful tool that enables proving the validity of certain computation without the need for the verifier to redo the computation. In the context of Aztec, users create transaction proofs that prove that correctness of the transaction, i.e. a certain set of rules were abided by the transaction. Such a transaction proof reveals nothing about the transaction itself other than the claim that it is a valid transaction. More generally, one can create a zkSNARK proof to prove the validity of any statemtent that can be represented in an NP-complete language.

The verification of a Plonk proof requires cryptographic operations like multi-scalar multiplication (MSM) and elliptic curve pairings. Interstingly, the computation required to verify a Plonk proof can itself be represented in form of an arithmetic circuit. Suppose we have a Plonk proof $\pi$ and we represent the algorithm to verify it, i.e. $\{0,1\}\leftarrow \textsf{verify}(\pi)$ in an arithmetic circuit $\circuit_{\pi}$. The proof generated by $\circuit_{\pi}$ would attest to the fact that $\textsf{verify}(\pi) = 1$ _only_ if the original proof $\pi$ was valid. In simple words, we can SNARK proof inside another SNARK proof. Why would we be interested in that? Because that would allow us to compress multiple SNARK proofs in a single SNARK proof!

### Proof Verification in Arithmetic Circuit

An UltraPlonk proof is represented as:

$$
\pi = \begin{pmatrix}
    [a]_1, [b]_1, [c]_1, [d]_1, [s]_1, [z_{\textsf{perm}}]_1, [z_{\textsf{lookup}}]_1, [t_1]_1, [t_2]_1, [t_3]_1, [t_4]_1, [W_{\mathfrak{z}}]_1, [W_{\mathfrak{z}\omega}]_1, \\
    \bar{a}, \bar{b}, \bar{c}, \bar{d}, \bar{s}_{\sigma_1}, \bar{s}_{\sigma_2}, \bar{z}_{\omega}
\end{pmatrix}
$$

We are interested in the verification algorithm of the Plonk proof $\pi$. At a high-level, the verifier work is divided in three parts:

1. Recovering challenges by correctly hashing the transcript
   $$
   \vec{c}\equiv (\textsf{init}, \eta, \beta, \gamma, \alpha, \mathfrak{z}, \nu, u) \leftarrow H(\pi),
   $$
2. Computing the evaluation of the quotient polynomial from the evaluations in the proof
   $$
   t_{\textsf{eval}} = f_{\textsf{teval}}(\pi \ | \ \vec{c}),
   $$
   where $f_{\textsf{teval}}$ is an operation performed by the verifier on the scalars in the proof $\pi$.
3. Computing the aggregated group elements:
   $$
   \begin{aligned}
   P_0 &:= f_{\textsf{msm}, 0}(\pi \ | \ \vec{c}), \\
   P_1 &:= f_{\textsf{msm}, 1}(\pi \ | \ \vec{c}),
   \end{aligned}
   $$
   where $f_{\textsf{msm}, 0}$ and $f_{\textsf{msm}, 1}$ are multi-scalar multiplication operations that the verifier needs to perform using the proof data and the computed challenges.
4. Checking the pairing equality
   $$
   e(P_0, [1]_2) \stackrel{?}{=} e(P_1, [x]_2).
   $$

If we want to verify a Plonk proof in an arithmetic circuit, we need to perform all of this computation using arithmetic gates. We refer to his circuit as the recursive verification circuit. This circuit is implemented in barretenberg in the file [`stdlib/recursion/verifier/verifier.hpp`](https://github.com/AztecProtocol/barretenberg/blob/3ce5e7e17ca7bb806373be833a44d55a8e584bda/cpp/src/aztec/stdlib/recursion/verifier/verifier.hpp). Note that we do not implement the 4th step of the verifier computation in the circuit. (We will come back to this point later.)

### Cost Analysis of Recursive Verifier Circuit

We are interested to understand how much each of the steps in the verifier computation costs in terms of arithmetic gates using TurboPlonk as well as UltraPlonk arithmetization. Here's a cost analysis of the gates used in the two proof systems for each verifier step for verifying an UltraPlonk proof $\pi$ inside the respective circuits.

$$
\begin{array}{|l|l|r|r|}
\hline \\[-8pt]
\text{No.} & \text{Description} & \text{ Ultra} & \text{ Turbo} \\[2pt] \hline \\[-8pt]
1 & \text{Recovering challenges:} \\[3pt]
& \textsf{init} = H(n, n_{\textsf{PI}}) & 2464 & 5165 \\[3pt]
& \eta = H(\textsf{init}, \textsf{PI}, [a]_1, [b]_1, [c]_1) & 4676 & 8584 \\[3pt]
& \beta, \gamma = H(\alpha, [d]_1, [s]_1, 0/1) & 3665 & 7103 \\[3pt]
& \alpha = H(\gamma, [z_{\textsf{perm}}]_1, [z_{\textsf{lookup}}]_1) & 3645 & 7088 \\[3pt]
& \mathfrak{z} = H(\alpha, [T_1]_1, [T_2]_1, [T_3]_1, [T_4]_1) & 4668 & 8796 \\[3pt]
& \nu = H(\mathfrak{z}, \bar{t}, \bar{a}, \dots) & 43199 & 87748 \\[3pt]
& u = H(\mathfrak{\nu}, [W_{\mathfrak{z}}]_1, [W_{\mathfrak{z}\omega}]_1) & 5507 & 11054 \\[3pt] \hline \\[-8pt]
2 & \text{Computing } t_{\textsf{eval}} \text{ and more:} \\[3pt]
& \text{Compute } \mathfrak{z}^n & 157 & 157 \\[3pt]
& \text{Compute } t_\textsf{eval} & 559 & 559 \\[3pt]
& \text{Lagrange evaluation } L_{n,1}(\mathfrak{z}) & 180 & 180 \\[3pt]
& \text{Miscellaneous } & 8291 & 11712 \\[3pt] \hline \\[-8pt]
3 & \text{Computing the aggregated group elements:} \\[3pt]
& \text{Check points on curve } & 2421 & 5950 \\[3pt]
& \text{MSM of large scalars } & 62824 & 181973 \\[3pt]
& \text{Compute } P_0 \ (\text{i.e. }f_{\textsf{msm}, 0}(.)) & 160258 & 443356 \\[3pt]
& \text{Compute } P_1 \ (\text{i.e. }f_{\textsf{msm}, 1}(.)) & 23732 & 74462 \\[3pt] \hline \\[-8pt]
& \text{Total:} & 326246 & 853887 \\[3pt] \hline
\end{array}
$$

Clearly, the maximum cost for verifying a Plonk proof inside a circuit is due to the multi-scalar multiplication operations as in the functions $f_{\textsf{msm}, 0}$ and $f_{\textsf{msm}, 1}$. Specifically, almost 50% of the total gate-cost goes into computing $P_0$. The next biggest cost is to compute the challenges by hashing the transcript repetitively. This means that more the number of challenges we sample, costlier the recursive verification gets.

### Veriying Multiple Proofs Recursively
